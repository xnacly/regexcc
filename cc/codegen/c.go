package codegen

import (
	"bufio"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"strconv"
	"strings"

	"github.com/xnacly/regexcc/cc/config"
	"github.com/xnacly/regexcc/cc/nfa"
)

type C struct{}

func (c *C) Generate(nfa nfa.NFA, conf config.Config) error {
	header, err := os.Create(conf.Name + ".h")
	if err != nil {
		return errors.Join(errors.New("Failed to create header file"), err)
	}
	source, err := os.Create(conf.Name + ".c")
	if err != nil {
		return errors.Join(errors.New("Failed to create source file"), err)
	}

	h := bufio.NewWriter(header)
	h.WriteString("#ifndef REGEXCC_")
	h.WriteString(strings.ToUpper(conf.Name))
	h.WriteString("_H\n#define REGEXCC_")
	h.WriteString(strings.ToUpper(conf.Name))
	h.WriteString(`_H
/* 
Generated by github.com/xnacly/regexcc 
If a bug occurs, please do open a new issue or send an email to contact@xnacly.me 
*/

#include <stdbool.h>
#include <stddef.h>

`)
	h.WriteString("// Returns true if `s` matches `")
	h.WriteString(conf.Input)
	h.WriteString("`\nbool ")
	h.WriteString(conf.Name)
	h.WriteString("_match(const char *s, size_t len);\n#endif")
	if err := h.Flush(); err != nil {
		return err
	}
	if err := header.Close(); err != nil {
		return err
	}

	src := bufio.NewWriter(source)
	src.WriteString("#include \"")
	src.WriteString(conf.Name)
	src.WriteString(".h\"\n")
	src.WriteString("// Returns true if `s` matches `")
	src.WriteString(conf.Input)
	src.WriteString("`\nbool ")
	src.WriteString(conf.Name)
	src.WriteString("_match(const char *s, size_t len){\n")

	// prelude inside of statemachine
	src.WriteString("\tsize_t i = 0;\n")
	src.WriteString("\tgoto S")
	src.WriteString(strconv.FormatInt(int64(nfa.Start), 10))
	src.WriteString(";\n")

	for _, state := range nfa.StatesInOrder() {
		slog.Debug("codegen", "generator", "c", "state", state)
		src.WriteString("S")
		src.WriteString(strconv.Itoa(int(state)))
		src.WriteString(":{\n")

		src.WriteString("\tif (i >= len) {\n")
		if nfa.Accept[state] {
			src.WriteString("\t\treturn true;\n")
		} else {
			src.WriteString("\t\treturn false;\n")
		}
		src.WriteString("\t}\n")

		for _, e := range nfa.EdgesFor(state) {
			if e.Label == nil {
				// epsilon
				src.WriteString(fmt.Sprintf("\tgoto S%d;\n", e.To))
			} else {
				lo, hi := e.Label[0], e.Label[1]
				if lo == hi {
					src.WriteString(fmt.Sprintf("\tif (i < len && s[i] == '%c') {\n", lo))
				} else {
					src.WriteString(fmt.Sprintf("\tif (i < len && s[i] >= '%c' && s[i] <= '%c') {\n", lo, hi))
				}
				src.WriteString("\t\ti++;\n")
				src.WriteString(fmt.Sprintf("\t\tgoto S%d;\n", e.To))
				src.WriteString("\t}\n")
			}
		}

		src.WriteString("\treturn false;\n")
		src.WriteString("}\n")
	}

	src.WriteRune('}')
	if err := src.Flush(); err != nil {
		return err
	}

	return source.Close()
}
